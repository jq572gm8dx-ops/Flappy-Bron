<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pac-Bron: King of the Court</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --lakers-gold: #fdb927;
            --lakers-purple: #552583;
            --floor-dark: #1a1a1a;
            --floor-light: #222;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none;
        }

        #ui-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            box-sizing: border-box;
            z-index: 5;
            height: 40px; /* Compact header */
        }

        .stat-box {
            background: rgba(85, 37, 131, 0.3);
            border: 2px solid var(--lakers-gold);
            padding: 4px 8px;
            border-radius: 4px;
            text-shadow: 2px 2px #000;
        }

        .label { color: var(--lakers-gold); font-size: 8px; margin-bottom: 2px; display: block; }
        .value { font-size: 10px; }

        #game-wrapper {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 4px solid var(--lakers-purple);
            background: #000;
            margin: auto; /* Vertically center */
        }

        canvas { display: block; }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; text-align: center;
        }

        h1 {
            color: var(--lakers-gold);
            text-shadow: 4px 4px var(--lakers-purple);
            font-size: clamp(20px, 5vw, 40px);
            margin-bottom: 10px;
        }

        p { font-size: clamp(10px, 3vw, 14px); color: #ccc; max-width: 80%; line-height: 1.5; }

        button {
            background: var(--lakers-purple);
            color: #fff;
            border: 2px solid var(--lakers-gold);
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 4vw, 16px);
            cursor: pointer;
            margin-top: 20px;
        }
        button:active { transform: scale(0.95); background: var(--lakers-gold); color: #000; }

        /* --- MOBILE D-PAD (Bottom Right) --- */
        #d-pad {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px; /* Moved to right side */
            width: 160px;
            height: 120px;
            z-index: 100;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            pointer-events: none;
        }

        .d-btn {
            background: rgba(85, 37, 131, 0.5); /* More transparent */
            border: 2px solid rgba(253, 185, 39, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            pointer-events: auto;
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(2px);
        }

        .d-btn:active { background: var(--lakers-gold); color: black; opacity: 1; }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        @media (hover: none) and (pointer: coarse) {
            #d-pad { display: grid; }
            #ui-container { padding: 2px 5px; }
        }

    </style>
</head>
<body>

    <div id="ui-container">
        <div class="stat-box">
            <span class="label">SCORE</span>
            <span class="value" id="score">0</span>
        </div>
        <div class="stat-box">
            <span class="label">HIGH SCORE</span>
            <span class="value" id="high-score">0</span>
        </div>
    </div>

    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h1>PAC-BRON</h1>
            <p>DUNK ON THE HATERS.</p>
            <p style="color:var(--lakers-gold); font-size: 0.8em; margin-top:5px;">Collect basketballs to score.</p>
            <button id="start-btn">TIP OFF</button>
            <div id="controls-hint" style="margin-top:20px; font-size:10px; color:#666;">ARROWS TO MOVE</div>
        </div>
    </div>

    <div id="d-pad">
        <div class="d-btn" id="btn-up">▲</div>
        <div class="d-btn" id="btn-left">◀</div>
        <div class="d-btn" id="btn-down">▼</div>
        <div class="d-btn" id="btn-right">▶</div>
    </div>

    <script>
        // --- Game Config ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        
        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Constants
        let TILE_SIZE = 25; 
        const MAP_WIDTH_TILES = 21; 
        const MAP_HEIGHT_TILES = 22; 
        
        const C_PURPLE = '#552583';
        const C_GOLD = '#fdb927';
        const C_SKIN = '#6d4c41'; 
        const C_BEARD = '#1a1a1a';
        const C_BALL = '#ff6b00';
        const C_FLOOR_1 = '#262626';
        const C_FLOOR_2 = '#2a2a2a';

        const baseMap = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
            [1,3,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,3,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1,1],
            [2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2],
            [1,1,1,1,1,0,1,2,1,1,9,1,1,2,1,0,1,1,1,1,1],
            [2,2,2,2,2,0,2,2,1,2,2,2,1,2,2,0,2,2,2,2,2], 
            [1,1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1,1],
            [2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2],
            [1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
            [1,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,1],
            [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
            [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let map = [];
        let score = 0;
        let highScore = localStorage.getItem('pacbron_hs') || 0;
        highScoreEl.innerText = highScore;
        let gameActive = false;
        let animationFrameId;

        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function resizeGame() {
            const maxWidth = window.innerWidth;
            const mobilePadHeight = (window.matchMedia("(hover: none) and (pointer: coarse)").matches) ? 10 : 0; // minimal buffer
            const maxHeight = window.innerHeight - 50 - mobilePadHeight;

            const tileW = Math.floor(maxWidth / MAP_WIDTH_TILES);
            const tileH = Math.floor(maxHeight / baseMap.length);
            
            TILE_SIZE = Math.min(tileW, tileH);
            
            if (window.innerWidth > 800 && TILE_SIZE > 35) TILE_SIZE = 35;

            canvas.width = MAP_WIDTH_TILES * TILE_SIZE;
            canvas.height = baseMap.length * TILE_SIZE;

            if (!gameActive && player) draw();
        }
        window.addEventListener('resize', resizeGame);

        class Entity {
            constructor(c, r) {
                this.x = c * TILE_SIZE + TILE_SIZE/2;
                this.y = r * TILE_SIZE + TILE_SIZE/2;
                this.dir = {x:0, y:0};
                this.nextDir = {x:0, y:0};
                this.speed = TILE_SIZE / 8; 
                this.radius = TILE_SIZE * 0.45; 
            }
            getCol() { return Math.floor(this.x / TILE_SIZE); }
            getRow() { return Math.floor(this.y / TILE_SIZE); }
            canMove(dx, dy) {
                const c = this.getCol() + dx;
                const r = this.getRow() + dy;
                if (r < 0 || r >= map.length || c < 0 || c >= map[0].length) return false;
                return map[r][c] !== 1;
            }
            move() {
                const centerX = this.getCol() * TILE_SIZE + TILE_SIZE/2;
                const centerY = this.getRow() * TILE_SIZE + TILE_SIZE/2;
                const dist = Math.sqrt((this.x-centerX)**2 + (this.y-centerY)**2);
                if (dist < this.speed) {
                    this.x = centerX;
                    this.y = centerY;
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                        if (this.canMove(this.nextDir.x, this.nextDir.y)) {
                            this.dir = {...this.nextDir};
                            this.nextDir = {x:0, y:0};
                        }
                    }
                    if (!this.canMove(this.dir.x, this.dir.y)) {
                        this.dir = {x:0, y:0};
                    }
                }
                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
            }
        }

        class PacBron extends Entity {
            constructor(c, r) { super(c, r); }
            update() {
                this.move();
                const c = this.getCol();
                const r = this.getRow();
                if (map[r][c] === 0) {
                    map[r][c] = 2;
                    score += 10;
                    playTone(200, 'triangle', 0.05);
                } else if (map[r][c] === 3) {
                    map[r][c] = 2;
                    score += 50;
                    playTone(400, 'square', 0.2);
                    activatePower();
                }
                if (score >= highScore) {
                    highScore = score;
                    highScoreEl.innerText = highScore;
                }
            }
            draw(ctx) {
                const r = this.radius;
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.dir.x < 0) ctx.scale(-1, 1);
                ctx.fillStyle = C_GOLD;
                ctx.beginPath();
                ctx.arc(0, r * 0.8, r, Math.PI, 0); 
                ctx.fill();
                ctx.strokeStyle = C_PURPLE;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = C_SKIN;
                ctx.beginPath();
                ctx.arc(0, -r * 0.1, r * 0.75, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = C_PURPLE;
                ctx.fillRect(-r*0.7, -r*0.6, r*1.4, r*0.35);
                ctx.fillStyle = C_GOLD; 
                ctx.fillRect(-2, -r*0.55, 4, 3);
                ctx.fillStyle = C_BEARD;
                ctx.beginPath();
                ctx.arc(0, -r*0.1, r*0.75, 0.2 * Math.PI, 0.8 * Math.PI); 
                ctx.lineTo(0, r * 0.2);
                ctx.fill();
                ctx.restore();
            }
        }

        class HoopGhost extends Entity {
            constructor(c, r, color, delay) {
                super(c, r);
                this.color = color;
                this.scared = false;
                this.active = false;
                this.speed = TILE_SIZE / 10;
                setTimeout(() => { this.active = true; }, delay);
            }
            update() {
                if (!this.active) return;
                const centerX = this.getCol() * TILE_SIZE + TILE_SIZE/2;
                const centerY = this.getRow() * TILE_SIZE + TILE_SIZE/2;
                const dist = Math.sqrt((this.x-centerX)**2 + (this.y-centerY)**2);

                if (dist < this.speed) {
                    this.x = centerX;
                    this.y = centerY;
                    const validMoves = [];
                    const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                    dirs.forEach(d => {
                        if (d.x === -this.dir.x && d.y === -this.dir.y && (this.dir.x!==0 || this.dir.y!==0)) return;
                        if (this.canMove(d.x, d.y)) validMoves.push(d);
                    });

                    if (validMoves.length > 0) {
                        if (this.scared) {
                            this.dir = validMoves[Math.floor(Math.random() * validMoves.length)];
                        } else if (Math.random() > 0.3 && player) {
                             let bestDir = validMoves[0];
                             let minD = 99999;
                             validMoves.forEach(d => {
                                 const nextX = this.x + d.x * TILE_SIZE;
                                 const nextY = this.y + d.y * TILE_SIZE;
                                 const distToP = Math.abs(nextX - player.x) + Math.abs(nextY - player.y);
                                 if (distToP < minD) { minD = distToP; bestDir = d; }
                             });
                             this.dir = bestDir;
                        } else {
                            this.dir = validMoves[Math.floor(Math.random() * validMoves.length)];
                        }
                    } else {
                        this.dir.x = -this.dir.x;
                        this.dir.y = -this.dir.y;
                    }
                }
                this.x += this.dir.x * (this.scared ? this.speed * 0.5 : this.speed);
                this.y += this.dir.y * (this.scared ? this.speed * 0.5 : this.speed);
            }
            draw(ctx) {
                const r = this.radius;
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // SCARED LOGIC
                if (this.scared) {
                    // Flash when timer is low (last 120 frames approx 2 seconds)
                    if (powerTimer < 120 && Math.floor(Date.now() / 100) % 2 === 0) {
                         // Flash White
                        ctx.fillStyle = '#fff';
                    } else {
                        // Blue
                        ctx.fillStyle = '#2196f3';
                    }
                    
                    ctx.font = `${Math.floor(r)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('3-0', 0, 0); 
                    ctx.restore();
                    return;
                }

                ctx.fillStyle = 'white';
                ctx.fillRect(-r, -r, r*2, r*1.2);
                ctx.strokeStyle = '#ccc';
                ctx.strokeRect(-r, -r, r*2, r*1.2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(-r*0.4, -r*0.4, r*0.8, r*0.5);
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-r*0.5, r*0.2);
                ctx.lineTo(r*0.5, r*0.2);
                ctx.stroke();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-r*0.5, r*0.2);
                ctx.lineTo(-r*0.3, r*0.8);
                ctx.lineTo(0, r*0.9);
                ctx.lineTo(r*0.3, r*0.8);
                ctx.lineTo(r*0.5, r*0.2);
                ctx.stroke();
                ctx.restore();
            }
        }

        let player;
        let ghosts = [];
        let powerTimer = 0;

        function init() {
            if (window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
                document.getElementById('controls-hint').innerText = "CONTROLS BOTTOM RIGHT";
            }
            resizeGame();
            map = baseMap.map(row => [...row]);
            score = 0;
            scoreEl.innerText = '0';
            player = new PacBron(10, 15);
            player.nextDir = {x:1, y:0};
            ghosts = [
                new HoopGhost(9, 10, '#ff0000', 0),
                new HoopGhost(10, 10, '#00ff00', 2000),
                new HoopGhost(11, 10, '#0000ff', 4000)
            ];
            gameActive = true;
            loop();
        }

        function activatePower() {
            // REDUCED TIMER: 350 frames is approx 6 seconds at 60fps
            powerTimer = 350; 
            ghosts.forEach(g => g.scared = true);
        }

        function checkCollisions() {
            for (let g of ghosts) {
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < TILE_SIZE * 0.8) {
                    if (g.scared) {
                        g.x = 10 * TILE_SIZE + TILE_SIZE/2;
                        g.y = 10 * TILE_SIZE + TILE_SIZE/2;
                        g.scared = false;
                        score += 200;
                        playTone(150, 'sawtooth', 0.1);
                    } else {
                        gameActive = false;
                        overlay.style.display = 'flex';
                        overlay.querySelector('h1').innerText = "FOUL OUT!";
                        overlay.querySelector('p').innerText = "FINAL SCORE: " + score;
                        startBtn.innerText = "REMATCH";
                    }
                }
            }
            let hasPellets = false;
            for(let r=0; r<map.length; r++) {
                for(let c=0; c<map[0].length; c++) {
                    if (map[r][c] === 0 || map[r][c] === 3) hasPellets = true;
                }
            }
            if (!hasPellets) {
                gameActive = false;
                overlay.style.display = 'flex';
                overlay.querySelector('h1').innerText = "CHAMPION!";
                overlay.querySelector('p').innerText = "COURT CLEARED";
            }
        }

        function draw() {
            ctx.fillStyle = C_FLOOR_1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = C_FLOOR_2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=TILE_SIZE) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=TILE_SIZE) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[0].length; c++) {
                    const tile = map[r][c];
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;
                    const cx = x + TILE_SIZE/2;
                    const cy = y + TILE_SIZE/2;

                    if (tile === 1) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
                        ctx.strokeStyle = C_PURPLE;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x+2,y+2,TILE_SIZE-4, TILE_SIZE-4);
                    } else if (tile === 0) {
                        ctx.fillStyle = C_BALL;
                        ctx.beginPath();
                        ctx.arc(cx, cy, TILE_SIZE * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - TILE_SIZE*0.25);
                        ctx.lineTo(cx, cy + TILE_SIZE*0.25);
                        ctx.stroke();
                    } else if (tile === 3) {
                        if (Math.floor(Date.now()/200)%2===0) {
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(cx, cy, TILE_SIZE * 0.4, 0, Math.PI*2);
                            ctx.fill();
                            ctx.shadowColor = '#ffd700';
                            ctx.shadowBlur = 10;
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    } else if (tile === 9) {
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.moveTo(x, cy);
                        ctx.lineTo(x+TILE_SIZE, cy);
                        ctx.stroke();
                    }
                }
            }
            if (player) player.draw(ctx);
            ghosts.forEach(g => g.draw(ctx));
        }

        function loop() {
            if (!gameActive) return;
            if (powerTimer > 0) {
                powerTimer--;
                if (powerTimer === 0) ghosts.forEach(g => g.scared = false);
            }
            player.update();
            ghosts.forEach(g => g.update());
            checkCollisions();
            draw();
            animationFrameId = requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', e => {
            if (!gameActive) return;
            switch(e.key) {
                case 'ArrowUp': player.nextDir = {x:0, y:-1}; break;
                case 'ArrowDown': player.nextDir = {x:0, y:1}; break;
                case 'ArrowLeft': player.nextDir = {x:-1, y:0}; break;
                case 'ArrowRight': player.nextDir = {x:1, y:0}; break;
            }
        });

        const setupBtn = (id, dx, dy) => {
            const btn = document.getElementById(id);
            const handler = (e) => {
                if(e.cancelable) e.preventDefault();
                if(gameActive && player) player.nextDir = {x:dx, y:dy};
            };
            btn.addEventListener('touchstart', handler, {passive:false});
            btn.addEventListener('mousedown', handler); 
        };
        setupBtn('btn-up', 0, -1);
        setupBtn('btn-down', 0, 1);
        setupBtn('btn-left', -1, 0);
        setupBtn('btn-right', 1, 0);

        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            if (!gameActive) return;
            e.preventDefault();
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            const dx = x - touchStartX;
            const dy = y - touchStartY;
            const threshold = 15; 
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > threshold) {
                    player.nextDir = {x: dx > 0 ? 1 : -1, y: 0};
                    touchStartX = x; touchStartY = y;
                }
            } else {
                if (Math.abs(dy) > threshold) {
                    player.nextDir = {x: 0, y: dy > 0 ? 1 : -1};
                    touchStartX = x; touchStartY = y;
                }
            }
        }, {passive: false});

        startBtn.addEventListener('click', () => {
            overlay.style.display = 'none';
            if (!player || !gameActive) init();
        });

        setTimeout(() => {
            resizeGame();
            init();
            gameActive = false;
            draw();
        }, 100);

    </script>
</body>
</html>